Требования:

1. Установить RabbitMQ. https://www.rabbitmq.com/download.html
2. Клонировать репозиторий
3. В проекте Publisher в файле appsettings.json в секции "RabbitMQ" указать параметры подключения к серверу брокера сообщений RabbitMQ. (изначально заполнен дэфолтными настройками)
4. В свойствах решения указать в качестве запускаемых проектов Publisher и Client.
5. Запустить (F5).

Принцип работы:

В проекте Publisher реализован HostedService FakeEdboService, который эмулирует работу с ЕДЕБО. FakeEdboService случайным образом добавляет новые записи EntranceRequest или редактирует существующие. 
При добавлении новой записи EntranceRequest в очередь сообщений отправляется событие EntranceRequestCreateMessage(сборка Contracts).
При добавлении изменении существующей записи EntranceRequest в очередь сообщений отправляется событие EntranceRequestUpdateMessage(сборка Contracts).

В проекте Client реализовано 2 потребителя событий(Consumers) EntranceRequestCreateConsumer и EntranceRequestUpdateConsumer. 
В классах потребителях в методе Consume реализовывается бизнес-логика, которая должна выполняться при добавлении/обновлении записи(в данный момент происходит просто вывод полученных данных к консоль).

Если сначала запустить проект Publisher(не запуская при этом Client), то события будут копиться в очереди. При запуске Client он получит все события которые произошли в то время как он был оффлайн.

Преимущества:

1. Возможность содержать базу в актуальном состоянии, практически, в режиме онлайн.
2. Минимизация объема трафика. Передаются только добавленые/отредактированые записи. 
3. Снижение нагрузки на БД. 

Неудобства:

1. Необходимо использовать общую библиотеку классов(сборка Contracts), в которой определены классы описывающие события.
